{
    "version": "https://jsonfeed.org/version/1",
    "title": "亚纳奇的Blog • All posts by \"斯坦福编程范式cs107\" tag",
    "description": "一个不知名的小菜鸡",
    "home_page_url": "http://Yanagi-Kon.github.io",
    "items": [
        {
            "id": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_7/",
            "url": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_7/",
            "title": "斯坦福编程范式CS107_7",
            "date_published": "2023-11-19T00:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_7\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_7\">#</a> 斯坦福编程范式 CS107_7</h1>\n<h2 id=\"使用栈来操纵字符串\"><a class=\"markdownIt-Anchor\" href=\"#使用栈来操纵字符串\">#</a> 使用栈来操纵字符串</h2>\n<p>接着上节课的栈的结构体</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elems<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 泛型中并不知道类型占用字节的大小，所以需要指定</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> loglength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> alloclength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span>stack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>以下是 main 函数内容</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> friends<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Al\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Bob\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Carl\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    stack stringStack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>stringStack<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>copy <span class=\"token operator\">=</span> <span class=\"token function\">strdup</span><span class=\"token punctuation\">(</span>friends<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 调用 strdup 会使用 malloc 函数，这和后面我们使用 free 函数是呼应的</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>stringStack<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>copy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>stringStack<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>stringStack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在上述例子中，如何构造 StackDispose 使其能够完全的将栈中的特殊元素，诸如指针元素中指针所指的内容传递给 free 函数释放动态申请的内存较为难以实现，下面进行实现。</p>\n<h3 id=\"stackh\"><a class=\"markdownIt-Anchor\" href=\"#stackh\">#</a> stack.h</h3>\n<p>在结构体中新增加了一个 void 函数。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elems<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 泛型中并不知道类型占用字节的大小，所以需要指定</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> loglength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> alloclength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>freefn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span>stack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"stackc\"><a class=\"markdownIt-Anchor\" href=\"#stackc\">#</a> stack.c</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>freefn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>freefn <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> loglength<span class=\"token punctuation\">,</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\ts<span class=\"token operator\">-></span><span class=\"token function\">freefn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>s<span class=\"token operator\">-></span>elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>s-&gt;freefn != NULL</code>  表示栈中有复杂的结构，如 char* 或者套用了另一个结构体之类的，因而需要我们调用自己的函数手动进行清楚空间。</p>\n<h3 id=\"main\"><a class=\"markdownIt-Anchor\" href=\"#main\">#</a> main</h3>\n<p>还是假设栈是字符串栈。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>stack stringStack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>stringStack<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>StringFree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StringFree</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>elem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"rotate函数\"><a class=\"markdownIt-Anchor\" href=\"#rotate函数\">#</a> rotate 函数</h2>\n<p>实现一个 rotate 函数，将一个数组的前几项内容整体全部复制并挪到数组的尾部，其余部分往前移动。</p>\n<p>调用 memcpy 函数时，地址是不能重叠的。memmove 函数与 memcpy 类似，只不过效率更低，对重叠元素进行处理，并进行数组移动。尽可能多用 memcpy 少用 memmove</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>front<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>middle<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> frontSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>middle <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>front<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> backSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>end <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>middle<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span>frontSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span>front<span class=\"token punctuation\">,</span>frontSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">memmove</span><span class=\"token punctuation\">(</span>front<span class=\"token punctuation\">,</span>middle<span class=\"token punctuation\">,</span>backSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 这里只能用 memmove 不能用 memcpy</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>end<span class=\"token operator\">-</span>frontSize<span class=\"token punctuation\">,</span>buffer<span class=\"token punctuation\">,</span>frontSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"c语言中通用的快速排序\"><a class=\"markdownIt-Anchor\" href=\"#c语言中通用的快速排序\">#</a> C 语言中通用的快速排序</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Qsort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>cmpfn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"c语言中的函数栈和堆栈\"><a class=\"markdownIt-Anchor\" href=\"#c语言中的函数栈和堆栈\">#</a> C 语言中的函数栈和堆栈</h2>\n<p>函数栈就不多说了，主函数高地址，每当调用新的函数时，就会入栈，从高地址到低地址，函数返回就会出栈。</p>\n<p>这里的堆栈指的不是一种优先队列数据结构，只是一块任意的字节。汇编代码一般都会在堆的低地址部分，由硬件进行管理；在汇编代码上方是由软件的堆内存管理器管理的，如 malloc、realloc、free 函数，是由软件管理的。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_7/image-20231108204836201.png\" alt=\"image-20231108204836201\"></p>\n<p>堆内存是一个很大的线性的字节数组。当我们执行以下代码时：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>a <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>malloc 函数会从堆的开始地址开始查找，找到第一块适合请求大小的空闲内存，并将这块内存标记为已占用，并返回内存的开始地址。继续执行下面的代码：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>b <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">60</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>函数发现开始的一段内存块已经被占用了，它会快速的到达这块内存块的尾部，从空闲位置进行内存分配，和上一步的步骤类似。如果再执行以下代码：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>free 函数会抹掉这段内存的被占用状态，释放内存。再执行如下命令：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>c <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">44</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>函数会查看第一段内存块，发现这是一段 40 字节大小的空内存块，由于小于 44 字节，所以会直接跳到下一段空闲的足够大的内存块。之后执行如下代码：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>d <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这一次第一段的 40 字节内存块就足够大了，函数会将这块切下来并记录下是 20 字节大，然后再次返回这个指针。</p>\n<p>以上只是粗略的进行讲述堆栈的内存分配过程，实际上是有一个数据结构用来管理着整个堆栈，它使用了很多 void * 来进行内存管理，名字是空闲记录的链表，它始终记录着第一个空闲记录的地址，能够方便的找出哪一部分能够满足下一个 malloc 的需求</p>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/",
            "url": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/",
            "title": "斯坦福编程范式CS107_8",
            "date_published": "2023-11-19T00:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_8\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_8\">#</a> 斯坦福编程范式 CS107_8</h1>\n<h2 id=\"关于内存\"><a class=\"markdownIt-Anchor\" href=\"#关于内存\">#</a> 关于内存</h2>\n<p>当我们执行下述命令时：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">40</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们都为以为返回的是 160 字节的内存，但实际上要比 160 多。在堆上，这段内存块开始的时候，会有一部分内存被用来记录这个内存块的大小。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231113103637297.png\" alt=\"image-20231113103637297\"></p>\n<p>当我们执行如下命令时：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 当你觉得 100 个 int 类型的有点多，60 个就足够了，你尝试执行下面的代码</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">free</span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">+</span><span class=\"token number\">60</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>以上是动态的申请空间。当执行 free 的时候，函数不会进行任何的完整性检查，malloc、free、reaclloc 都假设你是 C 或 C++ 语言编程高手。free 会机械的回退 4 或 8 字节，并将其中的内容理解为这一段要释放的内存的大小，并将这段长度的内存归还给堆。所以这样进行释放内存是不正确的。</p>\n<p>假设你以下述方式申请内存：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">free</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这是静态申请了数组空间，这种申请方式与堆内存无关，如果我们调用 free 函数，就会机械的向前回退 4 或 8 字节内存，并将其中的内容认为是要释放的内存的大小，并将这段长度的内存归还给堆。这样也不对，因为原先的内存不在堆中。</p>\n<h2 id=\"内存的分配\"><a class=\"markdownIt-Anchor\" href=\"#内存的分配\">#</a> 内存的分配</h2>\n<p>内存分配时有些实例会将堆进行分块，当一个内存申请小于 2 的 3 次方、5 次方、7 次方等，会被直接从堆的小、中、大块内存中进行分配，函数不会堆每次的内存分配精确的空间，而是通过规范大小的子内存段进行分配，这样可以更加快速的管理内存，并且内存段简洁且有组织。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231113105637044.png\" alt=\"image-20231113105637044\"></p>\n<h2 id=\"堆中内存可用与不可用表示\"><a class=\"markdownIt-Anchor\" href=\"#堆中内存可用与不可用表示\">#</a> 堆中内存可用与不可用表示</h2>\n<p>当使用 malloc 或 realloc 时，函数希望能够快速的扫描堆中未使用的块。函数使用一个内存块的链表来记录可分配的区域，每次调用 malloc、realloc 内存管理器都会遍历这个链表，并找到某个足够大的内存块来满足请求。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231113110446598.png\" alt=\"image-20231113110446598\"></p>\n<p>当使用 free 函数时，内存被释放并归还给堆时，这段内存块中的内容没有任何改变，没有清 0，只是其前四个字节指向下一段空闲内存开始地址，上一段空闲内存的指针指向这段内存的开始地址，现在系统认为这段内存就是空闲的。当然这样会导致内存中是分散的空闲内存，而没有整大段的空闲内存，有些实现会将空闲零碎的内存进行合并。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231113111703122.png\" alt=\"image-20231113111703122\"></p>\n<p>假设一个堆有 200 字节，其中使用了 40 字节，还有 160 字节的空闲，但都是零碎的：</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231113112534202.png\" alt=\"image-20231113112534202\"></p>\n<p>如果用户动态申请 100 字节的空间，则无法提供，因为剩下的 160 字节内存都是零碎的。假如我们对堆内存进行整理，把已经占用的 40 字节都挪到一起，那么剩下的 160 字节就是一个整体了。但是这样做会出现一个问题：原先被占用的内存块的开始地址已经被分配给用户了，如果进行移动，则内存块的开始地址会变化，这和原先用户所获得的地址不一致。</p>\n<h2 id=\"堆内存的句柄管理\"><a class=\"markdownIt-Anchor\" href=\"#堆内存的句柄管理\">#</a> 堆内存的句柄管理</h2>\n<p>除去经典管理的部分，堆中的相当一部分的内存是通过句柄的方式进行管理的，其不再返回一个直接指向内存的地址，而是一个二级指针，即用户得到的是一个地址列表的某一个地址，地址列表中的地址指向句柄管理的内存。这个地址列表和堆内存都由管理器进行管理，这样在进行琐碎内存合并的时候，就可以进行重定向地址。当然这样也存在问题，在移动的内存的时候不可能对内存进行访问。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231116151216582.png\" alt=\"image-20231116151216582\"></p>\n<p>所以在对某块内存进行使用时，就需要对系统发出 “不需要对这块内存进行压缩” 的命令，并在使用完这段内存的时候，再发出 “可以对这段内存进行压缩” 的命令。比较类似于并发。</p>\n<h2 id=\"栈段\"><a class=\"markdownIt-Anchor\" href=\"#栈段\">#</a> 栈段</h2>\n<p>栈的使用和函数的深度成比例。以下列函数为例</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">short</span> b<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">double</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>z<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token keyword\">double</span> m<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述函数在被调用时都会对变量进行申请空间，A 申请的空间用六边形进行表示，B 申请的空间用三角形进行表示，C 申请的空间用圆进行表示。调用 A 的时候，栈会减去一个六边形空间用以存储 A 中的局部变量；随后 A 调用 B，栈会减去一个三角形空间大小用以存储 B 中的局部变量，B 只能访问这个三角形内存空间中的内容，而不知道它上方的内存都是些什么；随后 B 调用 C，因此栈会减去一个圆的空间大小以存储 C 中的局部变量。当 C 调用完毕后，栈指针会上升回到调用 C 之前的位置，C 内存空间的内容就是那个圆不会被清空，但是也已经无法被访问了；然后 B 调用完毕，指针回到 B 调用之前的位置。最后 A 调用 C，再指针向下移动一个圆的内存空间大小，覆盖了原先三角形的空间。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231116154226894.png\" alt=\"image-20231116154226894\"></p>\n<h2 id=\"汇编代码和如何操作栈\"><a class=\"markdownIt-Anchor\" href=\"#汇编代码和如何操作栈\">#</a> 汇编代码和如何操作栈</h2>\n<p>使用 C 或者 C++ 模拟汇编语言的思路。</p>\n<p>在计算机中存在寄存器，寄存器和内存 RAM 相连，也和 ALU 逻辑运算器相连。寄存器通常是 4 字节大的，并且可以非常快速的进行访问。 <code>对任何变量进行加减乘除等运算时，都会将变量读取到寄存器中进行算数运算，不论变量是在栈中还是堆中，然后将结果写入其他寄存器中，然后将存储在寄存器中的内容写到属于它的内存中</code> 。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_8/image-20231116161410592.png\" alt=\"image-20231116161410592\"></p>\n<p>如果将 ALU 直接和 RAM 进行相连，就会使时间大大增加。</p>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/",
            "url": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/",
            "title": "斯坦福编程范式CS107_10",
            "date_published": "2023-11-19T00:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_10\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_10\">#</a> 斯坦福编程范式 CS107_10</h1>\n<h2 id=\"考虑完整的函数带有参数\"><a class=\"markdownIt-Anchor\" href=\"#考虑完整的函数带有参数\">#</a> 考虑完整的函数 (带有参数)</h2>\n<p>考虑申请一个如下的函数：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> bar<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>baz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">char</span> snink<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">short</span> <span class=\"token operator\">*</span>why<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数的传入变量和函数体内声明的局部变量在内存空间中是很近的。参数和局部变量的内存空间之间用了 4 字节进行分割，并且参数从右往左是从高地址到低地址的，所以 baz 的地址在 bar 之上。中间的四字节也十分重要，其中存储着调用函数的某些信息，它会告知我们是哪块代码调用了 <code>foo</code> 。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119164251173.png\" alt=\"image-20231119164251173\"></p>\n<p>考虑使用 main 函数进行案例：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当运行 main 函数时，我们将会演示整个内存空间是如何变化的。首先是 main 函数本身，具有两个参数 argc 和 argv，并且有一个 saved PC 的四字节空间</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119165116530.png\" alt=\"image-20231119165116530\"></p>\n<p>接着对 i 进行初始化，并赋值为 4 。</p>\n<p>此时汇编代码如下所示，SP 是一个特殊的寄存器，为 stack pointer 它总是指向栈的最低地址。</p>\n<pre><code class=\"language-assembly\">SP = SP - 4;\nM[SP] = 4;\n</code></pre>\n<p>接着开始调用 foo 函数，下面的汇编代码将 i 以及 i 的地址 作为参数传入预留给 foo 函数的参数空间中，并将控制权移交给  <code>foo</code> 。CALL 类似于一个跳转命令，它会跳转到 foo 函数的汇编代码中，并在其执行结束后再跳转回 main 中。</p>\n<p>SP 最后会加 8，这部分内容 (SP = SP + 8) 也会被存储到 saved PC 中，这部分操作实际上是在执行 CALL 函数后自动进行的。当 foo 函数执行完毕后，它能根据记录的信息跳回到调用之前的地址。</p>\n<pre><code class=\"language-assembly\">SP = SP - 8;\nR1 = M[SP + 8];\nR2 = SP + 8;\nM[SP] = R1;\nM[SP + 4] = R2;\nCALL &lt;foo&gt;;\nSP = SP + 8;\n</code></pre>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119173920404.png\" alt=\"image-20231119173920404\"></p>\n<p>随后我们开始执行 foo 函数中的代码。假设 foo 函数如下：</p>\n<p><code>&lt;foo&gt;:</code></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> bar<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>baz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">char</span> snink<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">short</span> <span class=\"token operator\">*</span>why<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    why <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">short</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>snink <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token operator\">*</span>why <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>foo <strong>首先</strong>为变量分配空间</p>\n<p>汇编代码如下所示：</p>\n<pre><code class=\"language-assembly\">SP = SP - 8;\n</code></pre>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119175325503.png\" alt=\"image-20231119175325503\"></p>\n<p><strong>随后</strong>执行</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>why <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">short</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>snink <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也就是认为一个 short 类型的地址 why 被赋为从图中圈圈的地方开始的地址。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119175641263.png\" alt=\"image-20231119175641263\"></p>\n<p>汇编代码：</p>\n<pre><code class=\"language-assembly\">R1 = SP + 6;\nM[SP] = R1;\n</code></pre>\n<p><strong>接着</strong>执行</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">*</span>why <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>汇编代码：</p>\n<pre><code class=\"language-assembly\">R1 = M[SP];\nM[R1] = .2 50;\n</code></pre>\n<p>现在 foo 函数中的内容执行完毕，现在函数应该退出并且以某种方式返回到 main 函数中，即执行下面的汇编代码。SP + 8 意思是将申请的局部空间释放掉，SP 回到申请局部变量空间前的位置。执行 RET 的时候，会让 saved PC 中的内容取出来，并读入 PC 中以便跳回到 main 函数中，并让 SP + 4。</p>\n<pre><code class=\"language-assembly\">SP = SP + 8;\nRET;\n</code></pre>\n<p>现在在 main 函数中，走到了汇编代码的这个位置。接着执行 RV = 0 即 <code>return 0；</code></p>\n<pre><code class=\"language-assembly\">CALL &lt;foo&gt;;\n--&gt; SP = SP + 8;\nRV = 0;\n</code></pre>\n<h2 id=\"举一个一般活动过程的例子\"><a class=\"markdownIt-Anchor\" href=\"#举一个一般活动过程的例子\">#</a> 举一个一般活动过程的例子</h2>\n<p>第一部分是函数的参数，被函数的调用者，比如 main 函数初始化并预留空间；第二部分是 saved PC；第三部分是 函数的局部变量，是被调用的函数自己初始化并预留的空间。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_10/image-20231119183230396.png\" alt=\"image-20231119183230396\"></p>\n<p>为什么要这样呢？为什么不直接由 main 函数预留这些空间？或者由被调用函数预留这些空间？因为谁申请的空间谁就要负责为这些空间进行赋值。所以参数部分只能由调用者进行初始化，局部变量只能由被调用的函数进行初始化。</p>\n<h2 id=\"举一个更有意义的函数的例子\"><a class=\"markdownIt-Anchor\" href=\"#举一个更有意义的函数的例子\">#</a> 举一个更有意义的函数的例子</h2>\n<p>函数 factorial 如下所示</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">fa</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">fa</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数的汇编代码如下所示</p>\n<pre><code class=\"language-assembly\">R1 = M[SP + 4];\nBNE R1,0,PC+12;\t\t//如果n不为0则进行跳转，否则按顺序执行\nRV = 1;\t\t\t\t//return 1\nRET;\t\t\t\t//返回到被调用前的位置\nR1 = M[SP+4];\nR1 = R1 - 1;\t\t// 先得到 n - 1 的值\nSP = SP - 4;\t\t// \nM[SP] = R1;\t\t\t// 将n - 1 存放到空间中，作为下一个调用函数的参数\nCALL&lt;fa&gt;;\nSP = SP + 4;\t\t// 调用的函数返回后，释放掉参数的空间\nR1 = M[SP + 4];\nRV = RV * R1;\t    // return n * RV\nRET;\n</code></pre>\n<p>这段例子在这节课的  <code>42 分钟</code> 开始有一个幻灯片例子，很清晰。</p>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/",
            "url": "http://yanagi-kon.github.io/2023/11/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/",
            "title": "斯坦福编程范式CS107_9",
            "date_published": "2023-11-19T00:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_9\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_9\">#</a> 斯坦福编程范式 CS107_9</h1>\n<h2 id=\"c语言与汇编语言的对照\"><a class=\"markdownIt-Anchor\" href=\"#c语言与汇编语言的对照\">#</a> C 语言与汇编语言的对照</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>上述代码在汇编中的形式为：</p>\n<pre><code class=\"language-assembly\">M[R1+4] = 10;\t\t//store operation\nR2 = M[R1+4];\t\t//load operation\nR3 = R2 + 7;\t\t//ALU operation\nM[R1] = R3;\t\t\t//store operation\nR2 = M[R1];\nR2 = R2 + 1;\nM[R1] = R2;\n</code></pre>\n<p>大写的 M 代表整个 RAM，将整个 RAM 看作是一个非常大的字节数组，R1 存储的是基地址，4 是偏移量。意思是，从基地址开始的四个字节写入数据 10。R1 存储的是 j 的地址。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/image-20231118153659076.png\" alt=\"image-20231118153659076\"></p>\n<p>有人可能会问，“为什么不直接使用 M [R1]++”。因为在汇编语言中不允许直接对地址中的值进行修够，必须先通过 load operation 将其装载到寄存器中，对寄存器进行操作，并再将结果写回内存，这会使汇编语言更加简单，指令简单则时钟频率更快。</p>\n<h3 id=\"下面举一个不是-4-字节变量的例子\"><a class=\"markdownIt-Anchor\" href=\"#下面举一个不是-4-字节变量的例子\">#</a> 下面举一个不是 4 字节变量的例子：</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">short</span> s1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">short</span> s2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>i <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>s1 <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\t</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>s2 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/image-20231118154657047.png\" alt=\"image-20231118154657047\"></p>\n<pre><code class=\"language-assembly\">M[R1+4] = 200;\t\n</code></pre>\n<p>对于 s1 = i 如果不可以直接用一下汇编语言实现</p>\n<pre><code class=\"language-assembly\">M[R1+2] = M[R1+4]; //这样翻译是错误的，因为汇编语言中，load 和 store 不能同时进行\n</code></pre>\n<p>也不可以用以下方法，因为 short 类型只有 2 字节，当被赋值 R2 这 4 个字节时，4 字节数据会被传输给 s1，s1 将会是 0（因为 R2 的高二位字节为 0），而 i 会变成一个非常大的数（因为 i 的高二位字节被分别赋值为了 0 和 200）。</p>\n<pre><code class=\"language-assembly\">R2 = M[R1+4];\t\nM[R1+2] = R2;\n</code></pre>\n<p>需要修改为：</p>\n<pre><code class=\"language-assembly\">R2 = M[R1+4];\t\nM[R1+2] = .2 R2; //移动两个字节，而不是4个\n</code></pre>\n<p>对于 s2 = s1 + 1; 汇编语言为：</p>\n<pre><code class=\"language-assembly\">R2 = .2 M[R1+2];\nR3 = R2 + 1;\nM[R1] = .2 R3;\n</code></pre>\n<h3 id=\"for循环是如何翻译的\"><a class=\"markdownIt-Anchor\" href=\"#for循环是如何翻译的\">#</a> for 循环是如何翻译的</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先是内存的申请，假设现在已经申请好了空间，那么执行 for 循环，第一步就是 i = 0</p>\n<pre><code class=\"language-assembly\">M[R1] = 0;\n</code></pre>\n<p>下面进行判断关系 i &lt; 4。这里的 BGT 是分支指令 branch greater or equal 的缩写，意思就是如果第一个参数大于等于第二个参数就进行跳转到第三个参数的地址上，否则继续按顺序执行。</p>\n<pre><code class=\"language-assembly\">R2 = M[R1];\nBGE  R2,4,PC+? \t//这里暂时不知道从基地址偏移多少个4字节(汇编指令的大小)\nR3 = M[R1];\t\t//R3就是i\nR4 = R3 * 4;\t//乘4因为int占4字节，R4是相较于数组基地址偏移后的地址\nR5 = R1 + 4;\t//R5是数组的基地址\nR6 = R5 + R4\t//R6是本轮循环要操作的数组元素的地址\nM[R6] = 0;\t\t//array[i] = 0;\n</code></pre>\n<p>接着进行 i ++</p>\n<pre><code class=\"language-assembly\">R2 = M[R1];\nR2 = R2 + 1;\nM[R1] = R2;\n</code></pre>\n<p>接着执行分支指令，跳回判断语句，这里是无条件跳转，即 JMP</p>\n<pre><code class=\"language-assembly\">JMP PC-40;\n</code></pre>\n<p>下面该写循环执行完，跳出循环后的 i – 了，并且现在我们可以把循环中的？给替换了，可以知道偏移应该是 10 条指令的大小，也就是 40。所以 <code>?=40</code> 。</p>\n<pre><code class=\"language-assembly\">R2 = M[R1];\nR2 = R2 - 1;\nM[R1] = R2;\n</code></pre>\n<p>对于 32 位操作系统，汇编代码指令一共有 32 位，为了能够表示 59 中汇编指令，需要 6 位进行表示，就是前六位是操作码。硬件会在一个时钟周期的前一部分，查看前 6 位机器码是什么，然后再决定如何解释剩下的 26 位。当然，这是使用定长编码对汇编指令进行编码，也可以使用非定长的编码方式。</p>\n<h2 id=\"指针和强制类型转换\"><a class=\"markdownIt-Anchor\" href=\"#指针和强制类型转换\">#</a> 指针和强制类型转换</h2>\n<p>下面以一个结构体为例：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">fraction</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> denom<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">fraction</span> pi<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>pi<span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> <span class=\"token number\">22</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>pi<span class=\"token punctuation\">.</span>denom <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>对于结构体，其内存如下图所示</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/image-20231118165258248.png\" alt=\"image-20231118165258248\"></p>\n<p>对于上述代码的汇编语言为：</p>\n<pre><code class=\"language-assembly\">M[R1] = 22;\nM[R1+4] = 7;\n</code></pre>\n<p>如果再进行以下操作：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">fraction</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">.</span>denom<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> denom <span class=\"token operator\">=</span> <span class=\"token number\">451</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这句代码的意思就是：</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_9/image-20231118165751885.png\" alt=\"image-20231118165751885\"></p>\n<p>那么这里的汇编代码是什么样的？如下：</p>\n<pre><code class=\"language-assembly\">M[R1+8] = 451;\n</code></pre>\n<p>pi 的地址是 M [R1]，pi.denom 的地址是 M [R1+4]，对其进行强制类型转换不会改变它的地址，-&gt;denom 的地址是 M [R1+4+4]。</p>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/06/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_6/",
            "url": "http://yanagi-kon.github.io/2023/11/06/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_6/",
            "title": "斯坦福编程范式CS107_6",
            "date_published": "2023-11-06T00:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_6\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_6\">#</a> 斯坦福编程范式 CS107_6</h1>\n<h2 id=\"实现一个整型的栈下\"><a class=\"markdownIt-Anchor\" href=\"#实现一个整型的栈下\">#</a> 实现一个整型的栈（下）</h2>\n<p>在 C 语言中结构体中的所有内容都是隐式的 public ，无法像 C++ 那样，实现 private protect 之类的限定词进行限制，但是我们可以假装里面的内容是不可见的，并要求通过我们定义的函数对其中的内容进行操作。</p>\n<p>下面内容在  <code>stack.h</code>  文件中</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>elems<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> logicalLen<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 已经使用的内存</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> alloclength<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 申请的内存大小</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span>stack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>上节课实现的 New 以及我们接下来要实现的其他函数，他们都在  <code>stack.c</code>  文件中</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    s<span class=\"token operator\">-></span>logicallen <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    s<span class=\"token operator\">-></span>allocLen <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    s<span class=\"token operator\">-></span>elems <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 动态分配内存函数，返回这一大块内存地址的开始地址</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 如果 assert 里面的内容为 false，assert 会终止程序，并告知终止位置</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>下面是 Dispose 的实现</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有人可能会问，能否直接使用  <code>free(s)</code>  实现直接对栈进行释放内存？答案是不可以，因为除了在 New 函数中，其他任何地方对这个栈变量分配空间。 <code>free(s)</code>  这样操作的假设是 s 栈空间已经被分配好，并将它被 New 函数所指定的地址作为参数传递给 Dispose。</p>\n<p>下面是 Push 的实现</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>logicalLen <span class=\"token operator\">==</span> s<span class=\"token operator\">-></span>alloclength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        s<span class=\"token operator\">-></span>alloclength <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        s<span class=\"token operator\">-></span>elems <span class=\"token operator\">=</span> <span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">,</span>s<span class=\"token operator\">-></span>alloclength <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">//realloc 首先假设第一个参数指向了一个动态申请的内存块，随后将其调整成第二个参数大小，如果可以调整，则返回第一个\t\t// 参数原先的地址，否则就使用 alloc 另开一块地址，返回新的地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">[</span>s<span class=\"token operator\">-></span>logicalLen<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>valus<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    s<span class=\"token operator\">-></span>logicalLen <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>下面是 Pop 的实现</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>logicalLen <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    logicalLen<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">[</span>s<span class=\"token operator\">-></span>logicalLen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"实现上述类型的通用模板\"><a class=\"markdownIt-Anchor\" href=\"#实现上述类型的通用模板\">#</a> 实现上述类型的通用模板</h2>\n<h3 id=\"stackh\"><a class=\"markdownIt-Anchor\" href=\"#stackh\">#</a> stack.h</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elems<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 泛型中并不知道类型占用字节的大小，所以需要指定</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> loglength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">int</span> alloclength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span>stack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"stackc\"><a class=\"markdownIt-Anchor\" href=\"#stackc\">#</a> stack.c</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>elemSize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    s<span class=\"token operator\">-></span>elemSize <span class=\"token operator\">=</span> elemSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    s<span class=\"token operator\">-></span>loglength <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    s<span class=\"token operator\">-></span>alloclength <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    s<span class=\"token operator\">-></span>elems <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token operator\">*</span>elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>loglength <span class=\"token operator\">==</span> s<span class=\"token operator\">-></span>alloclength<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token function\">StackGrow</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 这里添加了一个辅助函数用于进行内存空间拓展</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>target <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">+</span> s<span class=\"token operator\">-></span>loglength <span class=\"token operator\">*</span>s<span class=\"token operator\">-></span>elemSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span>elemAddr<span class=\"token punctuation\">,</span>s<span class=\"token operator\">-></span>elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    s<span class=\"token operator\">-></span>loglength<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当 <code>static</code>  修饰 c 或者 c<ins> 的函数原型时，这意味着，这是一个私有函数，不应该在函数所在文件之外的地方对其引用，因此在大多数情况下，它和 C</ins> 中的 private 有着相同的含义。其他的函数诸如我们上面写的 New、Disopose、Push 等都是全局函数，可以被其他的 <code>.o</code>  文件所使用</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">StackGrow</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    s<span class=\"token operator\">-></span>alloclength <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    s<span class=\"token operator\">-></span>elems <span class=\"token operator\">=</span> <span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems<span class=\"token punctuation\">,</span>s<span class=\"token operator\">-></span>alloclength <span class=\"token operator\">*</span> s<span class=\"token operator\">-></span>slemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>source <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>loglength <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> s<span class=\"token operator\">-></span>elemSize<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>elemAddr<span class=\"token punctuation\">,</span>source<span class=\"token punctuation\">,</span>s<span class=\"token operator\">-></span>elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    s<span class=\"token operator\">-></span>loglength<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/",
            "url": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/",
            "title": "斯坦福编程范式CS107_3",
            "date_published": "2023-11-05T12:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_3\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_3\">#</a> 斯坦福编程范式 CS107_3</h1>\n<h2 id=\"1大端存储小端存储\"><a class=\"markdownIt-Anchor\" href=\"#1大端存储小端存储\">#</a> 1. 大端存储，小端存储</h2>\n<p>端模式（Endian）的这个词出自 Jonathan Swift 书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，** 从圆头开始将鸡蛋敲开的人被归为 Big Endian，从尖头开始将鸡蛋敲开的人被归为 Littile Endian（这句话最为形象）。** 小人国的内战就源于吃鸡蛋时是究竟从大头（Big-Endian）敲开还是从小头（Little-Endian）敲开。在计算机业 Big Endian 和 Little Endian 也几乎引起一场战争。在计算机业界，Endian 表示数据在存储器中的存放顺序。下文举例说明在计算机中大小端模式的区别。</p>\n<p>如果将一个 32 位的整数 0x12345678 存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。为简单起见，本文使用 OP0 表示一个 32 位数据的最高字节 MSB（Most Significant Byte），使用 OP3 表示一个 32 位数据最低字节 LSB（Least Significant Byte）。</p>\n<table>\n<thead>\n<tr>\n<th>地址偏移</th>\n<th>大端模式</th>\n<th>小端模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x00</td>\n<td>12（OP0）</td>\n<td>78（OP3）</td>\n</tr>\n<tr>\n<td>0x01</td>\n<td>34（OP1）</td>\n<td>56（OP2）</td>\n</tr>\n<tr>\n<td>0x02</td>\n<td>56（OP2）</td>\n<td>34（OP1）</td>\n</tr>\n<tr>\n<td>0x03</td>\n<td>78（OP3）</td>\n<td>12（OP0）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>小端： <code>较高的有效字节存放在较高的的存储器地址</code> ， <code>较低的有效字节</code> 存放在 <code>较低的存储器地址</code> 。</li>\n<li>大端： <code>较高的有效字节存放在较低的存储器地址</code> ， <code>较低的有效字节</code> 存放在 <code>较高的存储器地址</code> 。</li>\n</ul>\n<p>采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将 <code>高数据位</code> 存放在 <code>低地址</code> ，小端方式将 <code>高数据位</code> 存放在 <code>高地址</code> 。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。大端与小端模式的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。</p>\n<p>用函数判断系统是 Big Endian 还是 Little Endian</p>\n<p>方法一：</p>\n<p>short 类型占用 2 字节， char 类型占用 1 字节</p>\n<pre><code class=\"language-C\">//如果字节序为big-endian，返回true;  \n//反之为   little-endian，返回false  \n\nbool IsBig_Endian()\n&#123;\n    unsigned short test = 0x1234;\n    if(*( (unsigned char*) &amp;test ) == 0x12)\n       return TRUE;\n   else\n       return FALSE;\n&#125;//IsBig_Endian()\n</code></pre>\n<p>方法二：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">checkCPUendian</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 返回 1，为小端；反之，为大端；</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">union</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>  a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    c<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span> <span class=\"token operator\">==</span> c<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ul>\n<li>\n<p>字节序的使用：</p>\n<p>大端模式处理器的字节序到网络字节序不需要转换，此时 ntohs (n)=n，ntohl =n；而小端模式处理器的字节序到网络字节必须要进行转换 (同理，有时候需要将大端字节顺序转换成小端字节顺序，也用这个函数，因为这个函数本来就是用来颠倒字节顺序的)，转换如下：</p>\n</li>\n</ul>\n<pre><code class=\"language-C\">#if defined(BIG_ENDIAN) &amp;&amp; !defined(LITTLE_ENDIAN)\n   #define htons(A)  (A)\n   #define htonl(A)  (A)\n   #define ntohs(A)  (A)\n   #define ntohl(A)  (A)\n\n#elif defined(LITTLE_ENDIAN) &amp;&amp; !defined(BIG_ENDIAN)\n   #define htons(A)  ((((uint16_t)(A) &amp; 0xff00) &gt;&gt; 8 ) | \\\\\n                      (((uint16_t)(A) &amp; 0x00ff) &lt;&lt; 8 ))\n   #define htonl(A)  ((((uint32_t)(A) &amp; 0xff000000) &gt;&gt; 24)  | \\\\\n                      (((uint32_t)(A) &amp; 0x00ff0000) &gt;&gt; 8 )  | \\\\\n                      (((uint32_t)(A) &amp; 0x0000ff00) &lt;&lt; 8 )  | \\\\\n                      (((uint32_t)(A) &amp; 0x000000ff) &lt;&lt; 24))\n   #define ntohs     htons\n   #define ntohl     htohl\n#else\n   #error Either BIG_ENDIAN or LITTLE_ENDIAN must be #defined, but not both.\n#endif\n</code></pre>\n<h2 id=\"2关于数组\"><a class=\"markdownIt-Anchor\" href=\"#2关于数组\">#</a> 2. 关于数组</h2>\n<h3 id=\"例子一\"><a class=\"markdownIt-Anchor\" href=\"#例子一\">#</a> 例子一</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>array 等价于 &amp;array [0]</p>\n<p>array + k 等价于 &amp;array [k]</p>\n<p>*array 等价于 array [0]</p>\n<p>*(array + k) 等价于 array [k]</p>\n<h3 id=\"例子二\"><a class=\"markdownIt-Anchor\" href=\"#例子二\">#</a> 例子二</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">128</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">short</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>cout <span class=\"token operator\">&lt;&lt;</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个时候打印出来的不是 128，而是 512 + 128，这个时候在 arr [3] 中的内容为：</p>\n<p>00000000 00000010 128 = 512 + 128 （这里在课上应该是采用的小端方法）</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">short</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"3关于struct\"><a class=\"markdownIt-Anchor\" href=\"#3关于struct\">#</a> 3. 关于 Struct</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">student</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">char</span> suid<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token keyword\">int</span> numUnits<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>student pupils<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>numUnits <span class=\"token operator\">=</span> <span class=\"token number\">21</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token function\">strdup</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Adam\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//strdup 是内存复制的缩写，动态地分配足够的空间来存储字符串</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/image-20231102162141584.png\" alt=\"image-20231102162141584\"></p>\n<p>进行如下操作后，内存中的情况如下图所示</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> pupils<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>suid <span class=\"token operator\">+</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/image-20231102162918438.png\" alt=\"image-20231102162918438\"></p>\n<p>继续进行如下操作</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>suid<span class=\"token punctuation\">,</span><span class=\"token string\">\"40415xx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/image-20231102163240269.png\" alt=\"image-20231102163240269\"></p>\n<p>继续进行如下操作</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span><span class=\"token string\">\"123456\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_3/image-20231102163922391.png\" alt=\"image-20231102163922391\"></p>\n<p>这样就会导致 student [0] 的 numUnits 会是一个非常大的数，但是 pupils [3].name 还是正常的 123456.</p>\n<p>继续进行如下操作</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pupils<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>suid<span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"4高级函数\"><a class=\"markdownIt-Anchor\" href=\"#4高级函数\">#</a> 4. 高级函数？</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ap<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>bp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>ap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token operator\">*</span>ap <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>bp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token operator\">*</span>bp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> <span class=\"token number\">117</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_4/",
            "url": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_4/",
            "title": "斯坦福编程范式CS107_4",
            "date_published": "2023-11-05T12:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_4\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_4\">#</a> 斯坦福编程范式 CS107_4</h1>\n<h2 id=\"使用c做出类似c中模板的效果\"><a class=\"markdownIt-Anchor\" href=\"#使用c做出类似c中模板的效果\">#</a> 使用 C 做出类似 C++ 中模板的效果</h2>\n<p>还是第三节中的交换函数，因为中间变量 temp 被声明为 int，所以系统就隐式默认这个在进行 4 字节的复制，所以我们不可能使用之前的函数进行 double 类型或者其他类型变量的交换。我们可以通过通用的指针类型 void * 来达到不提前限制类型的效果，它说明指向没有任何类型信息的某些东西。</p>\n<p>但如果你按照下述内容进行编码运行，就会出现问题</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp1<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">void</span> temp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>vp1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token operator\">*</span>vp1 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>vp2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token operator\">*</span>vp2 <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>首先，void temp 会报错，因为不能将变量定义为 void 类型。其次，不能对 void * 进行解引用，因为机器不知道要取出来多少字节来作为操作的一部分。因此我们还需要第三个参数，大小 size。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp1<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp2<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span>size<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span>vp1<span class=\"token punctuation\">,</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 和 strcpy 很像，但它不会检测 \\0，所以需要人为设置需要拷贝的字节大小</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>vp1<span class=\"token punctuation\">,</span>vp2<span class=\"token punctuation\">,</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>vp2<span class=\"token punctuation\">,</span>buffer<span class=\"token punctuation\">,</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">17</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">37</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>y<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在假设我们有以下变量</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>husband <span class=\"token operator\">=</span> <span class=\"token function\">strdup</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Fred\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>wife <span class=\"token operator\">=</span> <span class=\"token function\">strdup</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wilma\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_4/image-20231103184829084.png\" alt=\"image-20231103184829084\"></p>\n<p>如果我们想将 husband 和 wife 的名字调换一下，我们实际上只需要将其所指的指针调换即可，使 husband 指向 wilma，使 wife 指向 Fred。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>husband<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>wife<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \t<span class=\"token comment\">// 这里需要取地址，因为我们实际上交换的就是 h 和 w 所指向的内容，当我们想要交换两\t\t\t\t\t\t\t\t\t\t// 个 int 变量时，我们传入的时 int *，那么我们想要交换两个 char * 变量时，应该\t\t\t\t\t\t\t\t\t\t  // 传入的是 char **</span></pre></td></tr></table></figure><p>但是如果你忘记加 &amp;，程序仍然会编译并运行</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>husband<span class=\"token punctuation\">,</span>wife<span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样最终结果会直接改变两个字符串的值，分别为 wilm 和 Freda。</p>\n<h2 id=\"例子\"><a class=\"markdownIt-Anchor\" href=\"#例子\">#</a> 例子</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">lsearch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>size<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>key<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// 这一步在位的层面上比较是的 4 个字节是否相等</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果我们想让这个函数泛化，不只是查找一个 int 类型的 key，就需要多加一些参数。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">lsearch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>base <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>elemSize<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里将 void * 类型转换成 char * 类型，以便编译器能进行运算</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">memcmp</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>elemAddr<span class=\"token punctuation\">,</span>elemSize<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">return</span> elemAddr<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 在内存层面，一个字节一个字节进行比较</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述方法使用的是系统提供的比较函数，在下次课程中，将会使用下面的代码，在变量中加入了比较函数的指针 *cmpfn 来完成 memcmp 函数的功能。</p>\n<pre><code>void *lsearch(void *key, void *base,int n,int elemSize,int (*cmpfn)(void *,void *))&#123;\n\n&#125;\n</code></pre>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_5/",
            "url": "http://yanagi-kon.github.io/2023/11/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_5/",
            "title": "斯坦福编程范式CS107_5",
            "date_published": "2023-11-05T12:28:00.000Z",
            "content_html": "<h1 id=\"斯坦福编程范式cs107_5\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_5\">#</a> 斯坦福编程范式 CS107_5</h1>\n<h2 id=\"接着上节课的例子\"><a class=\"markdownIt-Anchor\" href=\"#接着上节课的例子\">#</a> 接着上节课的例子</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">lsearch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> elemSize<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>cmpfn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elemAddr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>base <span class=\"token operator\">+</span> i <span class=\"token operator\">*</span> elemSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">cmpfn</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>elemAddr<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\t<span class=\"token comment\">//cmpfn 函数就是比较传入的地址中的内容是否一样</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">return</span> elemAddr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>下面是一个使用上述函数的例子</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> number <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>found <span class=\"token operator\">=</span> <span class=\"token function\">lsearch</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>number<span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>IntCmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//IntCmp 是用来比较的函数，之后再进行实现</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">IntCmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elem1<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>elem2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ip1 <span class=\"token operator\">=</span> elem1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ip2 <span class=\"token operator\">=</span> elem2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>ip1 <span class=\"token operator\">-</span> <span class=\"token operator\">*</span>ip2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们再来举一个如果数组是字符串的例子</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_5/image-20231104095657611.png\" alt=\"image-20231104095657611\"></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> notes<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Ab\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"F#\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Gb\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"D\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>favoriteNote <span class=\"token operator\">=</span> <span class=\"token string\">\"Eb\"</span><span class=\"token punctuation\">;</span>\\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>found <span class=\"token operator\">=</span> <span class=\"token function\">lsearch</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>favoriteNote<span class=\"token punctuation\">,</span>notes<span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>StrCmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//&amp;favoriteNote 是一个 char **</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">StrCmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp1<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>vp2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s1 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>vp1<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 强制转换为 char ** 再对其解引用</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s2 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>vp2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">strcmp</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//clib 中自带的一个字符一个字符的比较</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述例子中，为何不直接将 vp 强制转换为 char * 类型的呢？因为我们的 notes 数组实际上相当于 char**，于是我们知道实际上 vp 与我们的字符串 &quot;Ab&quot; 之类的有两跳的距离，对 vp 解一次引用我们能得到的是指向字符串的首地址，再解一次引用得到的是字符串的首字符。strcmp 函数需要的是字符串的首地址，所以我们对 vp 强制转换为 char**，再解一次引用即可。如果直接使用 (char*) vp1，系统就会误把存储着字符串的地址认为是字符串，所以不能够直接强制转换为 char*。</p>\n<p>favoriteNote 是一个 char * 类型的变量，&amp;favoriteNote 是一个 char ** 类型的变量，当然也可以传入 favoriteNote，但是这样就破坏了函数变量处理的对称性，因为在之后的处理中，我们的 vp 都是 char ** 进行处理的，而 favoriteNote 按 char * 进行处理。</p>\n<h2 id=\"实现一个栈stackh\"><a class=\"markdownIt-Anchor\" href=\"#实现一个栈stackh\">#</a> 实现一个栈 Stack.h</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>elems<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> logicalLen<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 已经使用的内存</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">int</span> alloclength<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 申请的内存大小</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span>stack<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackDispose</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackPush</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">StackPop</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>上述的结构是 12 字节的，并且都是隐式的 public，但是我们要将其当作黑盒来处理，使用外在的函数对结构进行操作。</p>\n<p>当执行下面代码时，c 会为你保留一部分内存空间，但不会像 java 那样将内存空间清 0。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>stack s<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_5/image-20231104105236562.png\" alt=\"image-20231104105236562\"></p>\n<p>假设，当我们使用 StackNew (&amp;s); 时，系统会预申请一个能存入 4 个 int 的大小空间，这时进行任何操作都是非常迅速的，因为空间已经提前申请好了；当存入的数超过 4 个时，系统会再申请一个翻倍的空间，并把原先空间中的内容搬过来，原先空间删除。</p>\n<p>下面实现一部分内容：</p>\n<p><code>s</code>  是一个局部变量，它假设的是它指向的是一个 12 字节的内存空间，并且内容未知。</p>\n<p><img data-src=\"%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_5/image-20231104110715544.png\" alt=\"image-20231104110715544\"></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">StackNew</span><span class=\"token punctuation\">(</span>stack <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    s<span class=\"token operator\">-></span>logicallen <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    s<span class=\"token operator\">-></span>allocLen <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    s<span class=\"token operator\">-></span>elems <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 动态分配内存函数，返回这一大块内存地址的开始地址</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>elems <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 如果 assert 里面的内容为 false，assert 会终止程序，并告知终止位置</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        },
        {
            "id": "http://yanagi-kon.github.io/2023/09/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_2/",
            "url": "http://yanagi-kon.github.io/2023/09/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8FCS107_2/",
            "title": "斯坦福编程范式CS107_2",
            "date_published": "2023-09-19T12:28:00.000Z",
            "content_html": "<h2 id=\"斯坦福编程范式cs107_2\"><a class=\"markdownIt-Anchor\" href=\"#斯坦福编程范式cs107_2\">#</a> 斯坦福编程范式 CS107_2</h2>\n<table>\n<thead>\n<tr>\n<th><strong>C/C++</strong></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td>char</td>\n<td style=\"text-align:left\">1  byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td style=\"text-align:left\">2  bytes</td>\n</tr>\n<tr>\n<td>int</td>\n<td style=\"text-align:left\">2–4 bytes</td>\n</tr>\n<tr>\n<td>long</td>\n<td style=\"text-align:left\">4 bytes</td>\n</tr>\n<tr>\n<td>long long</td>\n<td style=\"text-align:left\">8  bytes</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:left\">4  bytes</td>\n</tr>\n<tr>\n<td>double</td>\n<td style=\"text-align:left\">8  bytes</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1为什么二进制中不简单的将-1-置在最左侧表示负数如-3为-1011\"><a class=\"markdownIt-Anchor\" href=\"#1为什么二进制中不简单的将-1-置在最左侧表示负数如-3为-1011\">#</a> 1.\t为什么二进制中不简单的将 1 置在最左侧表示负数（如，-3 为 1011）</h4>\n<p>因为如果是这样的话，-3 + 3 将等于：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1011</span> <span class=\"token operator\">+</span> <span class=\"token number\">0011</span> <span class=\"token operator\">=</span> <span class=\"token number\">1110</span></pre></td></tr></table></figure><p>显然结果是 -6 而不是 0。所以为了使正负数相加得到全 0 或全 1，如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1100</span> <span class=\"token operator\">+</span> <span class=\"token number\">0011</span> <span class=\"token operator\">=</span> <span class=\"token number\">1111</span></pre></td></tr></table></figure><p>这样得到全 1 后，我们只需要再 +1，就可以得到全 0：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1111</span> <span class=\"token operator\">+</span> <span class=\"token number\">0001</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token number\">0000</span>   这里的<span class=\"token number\">1</span>越界了所以不算</pre></td></tr></table></figure><p>所以实际上，我们采用 <strong>全部取反 并 +1</strong> 的方式用来表示负数： -3 （1101）. 这种方法就叫做  <code>2补码</code></p>\n<p>在 short 类型中，为了使 正数和负数 的数量一致，我们把最左边的那一比特空出，用于分割正数和负数，即正数最大为 $2^{15} -1 $：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span></pre></td></tr></table></figure><p>负数最小是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding=\"application/x-tex\">- 2^{15}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></span>：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span></pre></td></tr></table></figure><h4 id=\"2语言中变量间的相互赋值是如何实现的\"><a class=\"markdownIt-Anchor\" href=\"#2语言中变量间的相互赋值是如何实现的\">#</a> 2.\t语言中变量间的相互赋值是如何实现的？</h4>\n<p>当我们运行如下程序的时候：</p>\n<pre><code class=\"language-c++\">char ch = 'A';\nshort s = ch;\ncout &lt;&lt; s &lt;&lt; endl;\n------\n65\n</code></pre>\n<p>在内存中就是这样进行的：(每一个格子代表 1byte)，内存直接将 <code>ch</code>  的内容复制道 <code>s</code>  中。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ch</th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">65</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">s</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">65</td>\n</tr>\n</tbody>\n</table>\n<p>如果运行如下程序时：</p>\n<pre><code class=\"language-c++\">short s = 67;\nchar ch = s;\ncout &lt;&lt; ch &lt;&lt; endl;\n------\nC\n</code></pre>\n<p>进行如上赋值操作时，16bit 不能够被直接压缩成为 8bit 的模式。因而 C 和 C++ 中会简单的只关注低位上的内容，而把高位内容直接丢弃。</p>\n<p>如果进行如下程序时：</p>\n<pre><code class=\"language-c++\">short s = -1;\nint i = s;\t\n</code></pre>\n<p>内存中所进行的操作是这样的：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">s</th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">1…1</th>\n<th style=\"text-align:center\">1…1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">1…1</td>\n<td style=\"text-align:center\">1…1</td>\n<td style=\"text-align:center\">1…1</td>\n<td style=\"text-align:center\">1…1</td>\n</tr>\n</tbody>\n</table>\n<p>这种操作被称为 “符号扩展”。会将 符号位一位一位向上复制，就会导致 int 的前两字节内全变为 1，使得实际的数值仍然为  <code>-1</code></p>\n<h5 id=\"3浮点数float\"><a class=\"markdownIt-Anchor\" href=\"#3浮点数float\">#</a> 3.\t浮点数 float</h5>\n<p>对于浮点数 float，其将整数范围缩小，节省下来的 bit 位用来表示 2 的负次幂，这样就可以表示小数了。这是技术上可以实现的一种方式，但 <code>实际上并不是这样</code> 。</p>\n<p>实际上对于浮点数这样 4 byte 大小的数，浮点数将其中的 1 位用来表示符号，将其中的 8 位用来表示整数，剩下的 23 位用来表示小数。如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>s \t\t\t<span class=\"token function\">exp</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span>bit<span class=\"token punctuation\">)</span>\t\t\t<span class=\"token function\">xxxxxxxx</span><span class=\"token punctuation\">(</span><span class=\"token number\">23</span>bit<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>那么任何一个数都可以用如下形式进行表示：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><mi>S</mi></msup><mtext>  </mtext><mn>1.</mn><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mi>x</mi><mtext>  </mtext><mo>×</mo><mtext>  </mtext><msup><mn>2</mn><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>−</mo><mn>127</mn></mrow></msup><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><mtext>  </mtext><mo stretchy=\"false\">(</mo><mn>255</mn><mo>≥</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo>≥</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(-1)^S\\;1.xxxxxxxxx\\;×\\;2^{exp-127}     \\;\\;\\;\\;\\;\\;(255≥exp≥0)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1413309999999999em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913309999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.864108em;\"><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>例如，对于 7.0，我们可以表示为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>7.0</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mspace linebreak=\"newline\"></mspace><mn>3.5</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mspace linebreak=\"newline\"></mspace><mn>1.75</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">7.0×2^0\\\\\n3.5 ×2^1\\\\\n1.75×2^2\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">7</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>总归是可以表示到如上的标准形式。</p>\n<h5 id=\"4整数与浮点数之间的赋值\"><a class=\"markdownIt-Anchor\" href=\"#4整数与浮点数之间的赋值\">#</a> 4.\t整数与浮点数之间的赋值</h5>\n<p>如果有以下程序：</p>\n<pre><code class=\"language-c++\">int i = 5;\nfloat f = i;\ncout &lt;&lt; f &lt;&lt; endl;\n----------\n    \n</code></pre>\n<p>这其中变化是这样的：</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 被解释为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5.0</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">5.0×2^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span> 随后又被解释为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2.5</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">2.5×2^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span> 接着又被解释为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1.25</mn><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">1.25×2^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>. 因此 exp = 129，xxx=0.25。</p>\n<p>如果有以下程序：</p>\n<pre><code class=\"language-c++\">int i = 37;\nfloat f = *(float*)&amp;i; // 对i的地址求值\n</code></pre>\n<p>&amp;i 表示 i 的地址，i 是 int 类型的数，因而 &amp;i 是 int * 类型的指针。</p>\n<p>(float*)&amp;i 表示将 int * 类型 转变为了 float * 类型，bit 位置不会发生改变，而因为 37 对应的 bit 位 都落在了 xxxxxx 的位置上，因而 exp = 0，这就是一个奇小无比的数，而不是 37.0</p>\n<p>如果有以下程序：</p>\n<pre><code class=\"language-c++\">float f = 7.0;\nshort s = *(short *)&amp;f;\n</code></pre>\n<p>float 是 4 字节的数，指针指向 float 的最高位。当利用上述代码进行类型强制转换的时候，因为 short 只有 2 字节，因而 float 只有高位的两字节被直接复制过来，定义成了一个 short 类型的数。如下图所示：</p>\n<p><img data-src=\"image-20230921091608188.png\" alt=\"image-20230921091608188\"></p>\n",
            "tags": [
                "斯坦福编程范式CS107"
            ]
        }
    ]
}